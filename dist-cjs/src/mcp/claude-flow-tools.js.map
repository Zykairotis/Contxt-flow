{"version":3,"sources":["../../../src/mcp/claude-flow-tools.ts"],"sourcesContent":["/**\n * Claude-Flow specific MCP tools\n */\n\nimport type { MCPTool, MCPContext, AgentProfile, Task, MemoryEntry } from '../utils/types.js';\nimport type { ILogger } from '../core/logger.js';\nimport { getAvailableAgentTypes, getAgentTypeSchema, resolveLegacyAgentType } from '../constants/agent-types.js';\nimport type { Permissions } from './auth.js';\n\nexport interface ClaudeFlowToolContext extends MCPContext {\n  orchestrator?: any; // Reference to orchestrator instance\n}\n\n/**\n * Enhance tool schema with dynamic agent types\n */\nasync function enhanceToolWithAgentTypes(tool: MCPTool): Promise<MCPTool> {\n  const availableTypes = await getAvailableAgentTypes();\n  \n  // Clone the tool to avoid modifying the original\n  const enhancedTool = JSON.parse(JSON.stringify(tool));\n  \n  // Find and populate enum fields for agent types\n  function addEnumToAgentTypeFields(obj: any) {\n    if (typeof obj !== 'object' || obj === null) return;\n    \n    for (const [key, value] of Object.entries(obj)) {\n      if (typeof value === 'object' && value !== null) {\n        // Check if this is an agent type field\n        if (key === 'type' || key === 'filterByType' || key === 'assignToAgentType') {\n          const field = value as any;\n          if (field.type === 'string' && field.description?.includes('loaded dynamically from .claude/agents/')) {\n            field.enum = availableTypes;\n          }\n        }\n        addEnumToAgentTypeFields(value);\n      }\n    }\n  }\n  \n  addEnumToAgentTypeFields(enhancedTool.inputSchema);\n  return enhancedTool;\n}\n\n/**\n * Create all Claude-Flow specific MCP tools\n */\nexport async function createClaudeFlowTools(logger: ILogger): Promise<MCPTool[]> {\n  const tools = [\n    // Agent management tools\n    createSpawnAgentTool(logger),\n    createSpawnParallelAgentsTool(logger), // NEW: Phase 4 - Parallel spawning\n    createListAgentsTool(logger),\n    createTerminateAgentTool(logger),\n    createGetAgentInfoTool(logger),\n\n    // Query control tools (NEW: Phase 4 - Real-time control)\n    createQueryControlTool(logger),\n    createListQueriesTool(logger),\n\n    // Task management tools\n    createCreateTaskTool(logger),\n    createListTasksTool(logger),\n    createGetTaskStatusTool(logger),\n    createCancelTaskTool(logger),\n    createAssignTaskTool(logger),\n\n    // Memory management tools\n    createQueryMemoryTool(logger),\n    createStoreMemoryTool(logger),\n    createDeleteMemoryTool(logger),\n    createExportMemoryTool(logger),\n    createImportMemoryTool(logger),\n\n    // System monitoring tools\n    createGetSystemStatusTool(logger),\n    createGetMetricsTool(logger),\n    createHealthCheckTool(logger),\n\n    // Configuration tools\n    createGetConfigTool(logger),\n    createUpdateConfigTool(logger),\n    createValidateConfigTool(logger),\n\n    // Workflow tools\n    createExecuteWorkflowTool(logger),\n    createCreateWorkflowTool(logger),\n    createListWorkflowsTool(logger),\n\n    // Terminal management tools\n    createExecuteCommandTool(logger),\n    createListTerminalsTool(logger),\n    createCreateTerminalTool(logger),\n  ];\n\n  // Enhance tools with dynamic agent types\n  const enhancedTools = await Promise.all(\n    tools.map(tool => enhanceToolWithAgentTypes(tool))\n  );\n\n  return enhancedTools;\n}\n\nfunction createSpawnAgentTool(logger: ILogger): MCPTool {\n  return {\n    name: 'agents/spawn',\n    description: 'Spawn a new Claude agent with specified configuration',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        type: {\n          type: 'string',\n          // Note: enum will be populated dynamically at runtime\n          description: 'Type of specialized agent to spawn (loaded dynamically from .claude/agents/)',\n        },\n        name: {\n          type: 'string',\n          description: 'Display name for the agent',\n        },\n        capabilities: {\n          type: 'array',\n          items: { type: 'string' },\n          description: 'List of capabilities for the agent',\n        },\n        systemPrompt: {\n          type: 'string',\n          description: 'Custom system prompt for the agent',\n        },\n        maxConcurrentTasks: {\n          type: 'number',\n          default: 3,\n          description: 'Maximum number of concurrent tasks',\n        },\n        priority: {\n          type: 'number',\n          default: 5,\n          description: 'Agent priority level (1-10)',\n        },\n        environment: {\n          type: 'object',\n          description: 'Environment variables for the agent',\n        },\n        workingDirectory: {\n          type: 'string',\n          description: 'Working directory for the agent',\n        },\n      },\n      required: ['type', 'name'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Spawning agent', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      // Resolve legacy agent types to modern equivalents\n      const resolvedType = resolveLegacyAgentType(input.type);\n\n      const profile: AgentProfile = {\n        id: `agent_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n        name: input.name,\n        type: resolvedType,\n        capabilities: input.capabilities || [],\n        systemPrompt: input.systemPrompt || getDefaultSystemPrompt(resolvedType),\n        maxConcurrentTasks: input.maxConcurrentTasks || 3,\n        priority: input.priority || 5,\n        environment: input.environment,\n        workingDirectory: input.workingDirectory,\n      };\n\n      const sessionId = await context.orchestrator.spawnAgent(profile);\n\n      return {\n        agentId: profile.id,\n        sessionId,\n        profile,\n        originalType: input.type,\n        resolvedType,\n        status: 'spawned',\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createListAgentsTool(logger: ILogger): MCPTool {\n  return {\n    name: 'agents/list',\n    description: 'List all active agents in the system',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        includeTerminated: {\n          type: 'boolean',\n          default: false,\n          description: 'Include terminated agents in the list',\n        },\n        filterByType: {\n          type: 'string',\n          // Note: enum will be populated dynamically at runtime\n          description: 'Filter agents by type (loaded dynamically from .claude/agents/)',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Listing agents', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const agents = await context.orchestrator.listAgents();\n\n      let filteredAgents = agents;\n\n      if (!input.includeTerminated) {\n        filteredAgents = filteredAgents.filter((agent: any) => agent.status !== 'terminated');\n      }\n\n      if (input.filterByType) {\n        filteredAgents = filteredAgents.filter((agent: any) => agent.type === input.filterByType);\n      }\n\n      return {\n        agents: filteredAgents,\n        count: filteredAgents.length,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createTerminateAgentTool(logger: ILogger): MCPTool {\n  return {\n    name: 'agents/terminate',\n    description: 'Terminate a specific agent',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        agentId: {\n          type: 'string',\n          description: 'ID of the agent to terminate',\n        },\n        reason: {\n          type: 'string',\n          description: 'Reason for termination',\n        },\n        graceful: {\n          type: 'boolean',\n          default: true,\n          description: 'Whether to perform graceful shutdown',\n        },\n      },\n      required: ['agentId'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Terminating agent', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      await context.orchestrator.terminateAgent(input.agentId, {\n        reason: input.reason || 'Manual termination',\n        graceful: input.graceful !== false,\n      });\n\n      return {\n        agentId: input.agentId,\n        status: 'terminated',\n        reason: input.reason || 'Manual termination',\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createGetAgentInfoTool(logger: ILogger): MCPTool {\n  return {\n    name: 'agents/info',\n    description: 'Get detailed information about a specific agent',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        agentId: {\n          type: 'string',\n          description: 'ID of the agent',\n        },\n      },\n      required: ['agentId'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Getting agent info', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const agentInfo = await context.orchestrator.getAgentInfo(input.agentId);\n\n      if (!agentInfo) {\n        throw new Error(`Agent not found: ${input.agentId}`);\n      }\n\n      return {\n        agent: agentInfo,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createCreateTaskTool(logger: ILogger): MCPTool {\n  return {\n    name: 'tasks/create',\n    description: 'Create a new task for execution',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        type: {\n          type: 'string',\n          description: 'Type of task to create',\n        },\n        description: {\n          type: 'string',\n          description: 'Description of the task',\n        },\n        priority: {\n          type: 'number',\n          default: 5,\n          description: 'Task priority (1-10)',\n        },\n        dependencies: {\n          type: 'array',\n          items: { type: 'string' },\n          description: 'List of task IDs this task depends on',\n        },\n        assignToAgent: {\n          type: 'string',\n          description: 'Specific agent ID to assign the task to',\n        },\n        assignToAgentType: {\n          type: 'string',\n          // Note: enum will be populated dynamically at runtime\n          description: 'Type of specialized agent to assign the task to (loaded dynamically from .claude/agents/)',\n        },\n        input: {\n          type: 'object',\n          description: 'Input data for the task',\n        },\n        timeout: {\n          type: 'number',\n          description: 'Task timeout in milliseconds',\n        },\n      },\n      required: ['type', 'description'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Creating task', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const task: Partial<Task> = {\n        type: input.type,\n        description: input.description,\n        priority: input.priority || 5,\n        dependencies: input.dependencies || [],\n        input: input.input || {},\n        status: 'pending',\n        createdAt: new Date(),\n      };\n\n      const taskId = await context.orchestrator.createTask(task);\n\n      // Handle assignment\n      if (input.assignToAgent) {\n        await context.orchestrator.assignTask(taskId, input.assignToAgent);\n      } else if (input.assignToAgentType) {\n        await context.orchestrator.assignTaskToType(taskId, input.assignToAgentType);\n      }\n\n      return {\n        taskId,\n        task: { ...task, id: taskId },\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createListTasksTool(logger: ILogger): MCPTool {\n  return {\n    name: 'tasks/list',\n    description: 'List tasks with optional filtering',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        status: {\n          type: 'string',\n          enum: ['pending', 'queued', 'assigned', 'running', 'completed', 'failed', 'cancelled'],\n          description: 'Filter by task status',\n        },\n        agentId: {\n          type: 'string',\n          description: 'Filter by assigned agent ID',\n        },\n        type: {\n          type: 'string',\n          description: 'Filter by task type',\n        },\n        limit: {\n          type: 'number',\n          default: 50,\n          description: 'Maximum number of tasks to return',\n        },\n        offset: {\n          type: 'number',\n          default: 0,\n          description: 'Number of tasks to skip',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Listing tasks', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const tasks = await context.orchestrator.listTasks({\n        status: input.status,\n        agentId: input.agentId,\n        type: input.type,\n        limit: input.limit || 50,\n        offset: input.offset || 0,\n      });\n\n      return {\n        tasks,\n        count: tasks.length,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createGetTaskStatusTool(logger: ILogger): MCPTool {\n  return {\n    name: 'tasks/status',\n    description: 'Get detailed status of a specific task',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        taskId: {\n          type: 'string',\n          description: 'ID of the task',\n        },\n      },\n      required: ['taskId'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Getting task status', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const task = await context.orchestrator.getTask(input.taskId);\n\n      if (!task) {\n        throw new Error(`Task not found: ${input.taskId}`);\n      }\n\n      return {\n        task,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createCancelTaskTool(logger: ILogger): MCPTool {\n  return {\n    name: 'tasks/cancel',\n    description: 'Cancel a pending or running task',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        taskId: {\n          type: 'string',\n          description: 'ID of the task to cancel',\n        },\n        reason: {\n          type: 'string',\n          description: 'Reason for cancellation',\n        },\n      },\n      required: ['taskId'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Cancelling task', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      await context.orchestrator.cancelTask(input.taskId, input.reason || 'Manual cancellation');\n\n      return {\n        taskId: input.taskId,\n        status: 'cancelled',\n        reason: input.reason || 'Manual cancellation',\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createAssignTaskTool(logger: ILogger): MCPTool {\n  return {\n    name: 'tasks/assign',\n    description: 'Assign a task to a specific agent',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        taskId: {\n          type: 'string',\n          description: 'ID of the task to assign',\n        },\n        agentId: {\n          type: 'string',\n          description: 'ID of the agent to assign the task to',\n        },\n      },\n      required: ['taskId', 'agentId'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Assigning task', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      await context.orchestrator.assignTask(input.taskId, input.agentId);\n\n      return {\n        taskId: input.taskId,\n        agentId: input.agentId,\n        status: 'assigned',\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createQueryMemoryTool(logger: ILogger): MCPTool {\n  return {\n    name: 'memory/query',\n    description: 'Query agent memory with filters and search',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        agentId: {\n          type: 'string',\n          description: 'Filter by agent ID',\n        },\n        sessionId: {\n          type: 'string',\n          description: 'Filter by session ID',\n        },\n        type: {\n          type: 'string',\n          enum: ['observation', 'insight', 'decision', 'artifact', 'error'],\n          description: 'Filter by entry type',\n        },\n        tags: {\n          type: 'array',\n          items: { type: 'string' },\n          description: 'Filter by tags',\n        },\n        search: {\n          type: 'string',\n          description: 'Full-text search query',\n        },\n        startTime: {\n          type: 'string',\n          format: 'date-time',\n          description: 'Filter entries after this time',\n        },\n        endTime: {\n          type: 'string',\n          format: 'date-time',\n          description: 'Filter entries before this time',\n        },\n        limit: {\n          type: 'number',\n          default: 50,\n          description: 'Maximum number of entries to return',\n        },\n        offset: {\n          type: 'number',\n          default: 0,\n          description: 'Number of entries to skip',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Querying memory', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const query = {\n        agentId: input.agentId,\n        sessionId: input.sessionId,\n        type: input.type,\n        tags: input.tags,\n        search: input.search,\n        startTime: input.startTime ? new Date(input.startTime) : undefined,\n        endTime: input.endTime ? new Date(input.endTime) : undefined,\n        limit: input.limit || 50,\n        offset: input.offset || 0,\n      };\n\n      const entries = await context.orchestrator.queryMemory(query);\n\n      return {\n        entries,\n        count: entries.length,\n        query,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createStoreMemoryTool(logger: ILogger): MCPTool {\n  return {\n    name: 'memory/store',\n    description: 'Store a new memory entry',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        agentId: {\n          type: 'string',\n          description: 'Agent ID for the memory entry',\n        },\n        sessionId: {\n          type: 'string',\n          description: 'Session ID for the memory entry',\n        },\n        type: {\n          type: 'string',\n          enum: ['observation', 'insight', 'decision', 'artifact', 'error'],\n          description: 'Type of memory entry',\n        },\n        content: {\n          type: 'string',\n          description: 'Content of the memory entry',\n        },\n        context: {\n          type: 'object',\n          description: 'Context data for the memory entry',\n        },\n        tags: {\n          type: 'array',\n          items: { type: 'string' },\n          description: 'Tags for the memory entry',\n        },\n        parentId: {\n          type: 'string',\n          description: 'Parent memory entry ID',\n        },\n      },\n      required: ['agentId', 'sessionId', 'type', 'content'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Storing memory', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const entry: Partial<MemoryEntry> = {\n        agentId: input.agentId,\n        sessionId: input.sessionId,\n        type: input.type,\n        content: input.content,\n        context: input.context || {},\n        tags: input.tags || [],\n        parentId: input.parentId,\n        timestamp: new Date(),\n        version: 1,\n      };\n\n      const entryId = await context.orchestrator.storeMemory(entry);\n\n      return {\n        entryId,\n        entry: { ...entry, id: entryId },\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createDeleteMemoryTool(logger: ILogger): MCPTool {\n  return {\n    name: 'memory/delete',\n    description: 'Delete a memory entry',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        entryId: {\n          type: 'string',\n          description: 'ID of the memory entry to delete',\n        },\n      },\n      required: ['entryId'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Deleting memory', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      await context.orchestrator.deleteMemory(input.entryId);\n\n      return {\n        entryId: input.entryId,\n        status: 'deleted',\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createExportMemoryTool(logger: ILogger): MCPTool {\n  return {\n    name: 'memory/export',\n    description: 'Export memory entries to a file',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        format: {\n          type: 'string',\n          enum: ['json', 'csv', 'markdown'],\n          default: 'json',\n          description: 'Export format',\n        },\n        agentId: {\n          type: 'string',\n          description: 'Filter by agent ID',\n        },\n        sessionId: {\n          type: 'string',\n          description: 'Filter by session ID',\n        },\n        startTime: {\n          type: 'string',\n          format: 'date-time',\n          description: 'Export entries after this time',\n        },\n        endTime: {\n          type: 'string',\n          format: 'date-time',\n          description: 'Export entries before this time',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Exporting memory', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const exportResult = await context.orchestrator.exportMemory({\n        format: input.format || 'json',\n        agentId: input.agentId,\n        sessionId: input.sessionId,\n        startTime: input.startTime ? new Date(input.startTime) : undefined,\n        endTime: input.endTime ? new Date(input.endTime) : undefined,\n      });\n\n      return {\n        ...exportResult,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createImportMemoryTool(logger: ILogger): MCPTool {\n  return {\n    name: 'memory/import',\n    description: 'Import memory entries from a file',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        filePath: {\n          type: 'string',\n          description: 'Path to the file to import',\n        },\n        format: {\n          type: 'string',\n          enum: ['json', 'csv'],\n          default: 'json',\n          description: 'Import format',\n        },\n        mergeStrategy: {\n          type: 'string',\n          enum: ['skip', 'overwrite', 'version'],\n          default: 'skip',\n          description: 'Strategy for handling duplicate entries',\n        },\n      },\n      required: ['filePath'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Importing memory', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const importResult = await context.orchestrator.importMemory({\n        filePath: input.filePath,\n        format: input.format || 'json',\n        mergeStrategy: input.mergeStrategy || 'skip',\n      });\n\n      return {\n        ...importResult,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createGetSystemStatusTool(logger: ILogger): MCPTool {\n  return {\n    name: 'system/status',\n    description: 'Get comprehensive system status information',\n    inputSchema: {\n      type: 'object',\n      properties: {},\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Getting system status', { sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const status = await context.orchestrator.getSystemStatus();\n\n      return {\n        ...status,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createGetMetricsTool(logger: ILogger): MCPTool {\n  return {\n    name: 'system/metrics',\n    description: 'Get system performance metrics',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        timeRange: {\n          type: 'string',\n          enum: ['1h', '6h', '24h', '7d'],\n          default: '1h',\n          description: 'Time range for metrics',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Getting system metrics', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const metrics = await context.orchestrator.getMetrics(input.timeRange || '1h');\n\n      return {\n        metrics,\n        timeRange: input.timeRange || '1h',\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createHealthCheckTool(logger: ILogger): MCPTool {\n  return {\n    name: 'system/health',\n    description: 'Perform a comprehensive health check',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        deep: {\n          type: 'boolean',\n          default: false,\n          description: 'Perform deep health check including component tests',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Performing health check', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const healthCheck = await context.orchestrator.performHealthCheck(input.deep || false);\n\n      return {\n        ...healthCheck,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createGetConfigTool(logger: ILogger): MCPTool {\n  return {\n    name: 'config/get',\n    description: 'Get current system configuration',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        section: {\n          type: 'string',\n          enum: ['orchestrator', 'terminal', 'memory', 'coordination', 'mcp', 'logging'],\n          description: 'Specific configuration section to retrieve',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Getting configuration', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const config = await context.orchestrator.getConfig(input.section);\n\n      return {\n        config,\n        section: input.section,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createUpdateConfigTool(logger: ILogger): MCPTool {\n  return {\n    name: 'config/update',\n    description: 'Update system configuration',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        section: {\n          type: 'string',\n          enum: ['orchestrator', 'terminal', 'memory', 'coordination', 'mcp', 'logging'],\n          description: 'Configuration section to update',\n        },\n        config: {\n          type: 'object',\n          description: 'Configuration values to update',\n        },\n        restart: {\n          type: 'boolean',\n          default: false,\n          description: 'Restart affected components after update',\n        },\n      },\n      required: ['section', 'config'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Updating configuration', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const result = await context.orchestrator.updateConfig(\n        input.section,\n        input.config,\n        input.restart || false,\n      );\n\n      return {\n        ...result,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createValidateConfigTool(logger: ILogger): MCPTool {\n  return {\n    name: 'config/validate',\n    description: 'Validate a configuration object',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        config: {\n          type: 'object',\n          description: 'Configuration object to validate',\n        },\n      },\n      required: ['config'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Validating configuration', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const validation = await context.orchestrator.validateConfig(input.config);\n\n      return {\n        ...validation,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createExecuteWorkflowTool(logger: ILogger): MCPTool {\n  return {\n    name: 'workflow/execute',\n    description: 'Execute a workflow from a file or definition',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        filePath: {\n          type: 'string',\n          description: 'Path to workflow file',\n        },\n        workflow: {\n          type: 'object',\n          description: 'Inline workflow definition',\n        },\n        parameters: {\n          type: 'object',\n          description: 'Parameters to pass to the workflow',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Executing workflow', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      if (!input.filePath && !input.workflow) {\n        throw new Error('Either filePath or workflow must be provided');\n      }\n\n      const result = await context.orchestrator.executeWorkflow({\n        filePath: input.filePath,\n        workflow: input.workflow,\n        parameters: input.parameters || {},\n      });\n\n      return {\n        ...result,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createCreateWorkflowTool(logger: ILogger): MCPTool {\n  return {\n    name: 'workflow/create',\n    description: 'Create a new workflow definition',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        name: {\n          type: 'string',\n          description: 'Name of the workflow',\n        },\n        description: {\n          type: 'string',\n          description: 'Description of the workflow',\n        },\n        tasks: {\n          type: 'array',\n          items: {\n            type: 'object',\n            properties: {\n              id: { type: 'string' },\n              type: { type: 'string' },\n              description: { type: 'string' },\n              dependencies: {\n                type: 'array',\n                items: { type: 'string' },\n              },\n              assignTo: { type: 'string' },\n            },\n            required: ['id', 'type', 'description'],\n          },\n          description: 'List of tasks in the workflow',\n        },\n        savePath: {\n          type: 'string',\n          description: 'Path to save the workflow file',\n        },\n      },\n      required: ['name', 'tasks'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Creating workflow', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const workflow = {\n        name: input.name,\n        description: input.description,\n        tasks: input.tasks,\n        created: new Date().toISOString(),\n      };\n\n      const result = await context.orchestrator.createWorkflow(workflow, input.savePath);\n\n      return {\n        ...result,\n        workflow,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createListWorkflowsTool(logger: ILogger): MCPTool {\n  return {\n    name: 'workflow/list',\n    description: 'List available workflows',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        directory: {\n          type: 'string',\n          description: 'Directory to search for workflows',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Listing workflows', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const workflows = await context.orchestrator.listWorkflows(input.directory);\n\n      return {\n        workflows,\n        count: workflows.length,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createExecuteCommandTool(logger: ILogger): MCPTool {\n  return {\n    name: 'terminal/execute',\n    description: 'Execute a command in a terminal session',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        command: {\n          type: 'string',\n          description: 'Command to execute',\n        },\n        args: {\n          type: 'array',\n          items: { type: 'string' },\n          description: 'Command arguments',\n        },\n        cwd: {\n          type: 'string',\n          description: 'Working directory for the command',\n        },\n        env: {\n          type: 'object',\n          description: 'Environment variables',\n        },\n        timeout: {\n          type: 'number',\n          default: 30000,\n          description: 'Command timeout in milliseconds',\n        },\n        terminalId: {\n          type: 'string',\n          description: 'Specific terminal ID to use',\n        },\n      },\n      required: ['command'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Executing command', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const result = await context.orchestrator.executeCommand({\n        command: input.command,\n        args: input.args,\n        cwd: input.cwd,\n        env: input.env,\n        timeout: input.timeout || 30000,\n        terminalId: input.terminalId,\n      });\n\n      return {\n        ...result,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createListTerminalsTool(logger: ILogger): MCPTool {\n  return {\n    name: 'terminal/list',\n    description: 'List all terminal sessions',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        includeIdle: {\n          type: 'boolean',\n          default: true,\n          description: 'Include idle terminals',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Listing terminals', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const terminals = await context.orchestrator.listTerminals(input.includeIdle !== false);\n\n      return {\n        terminals,\n        count: terminals.length,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction createCreateTerminalTool(logger: ILogger): MCPTool {\n  return {\n    name: 'terminal/create',\n    description: 'Create a new terminal session',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        cwd: {\n          type: 'string',\n          description: 'Working directory for the terminal',\n        },\n        env: {\n          type: 'object',\n          description: 'Environment variables',\n        },\n        shell: {\n          type: 'string',\n          description: 'Shell to use (bash, zsh, etc.)',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Creating terminal', { input, sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const terminal = await context.orchestrator.createTerminal({\n        cwd: input.cwd,\n        env: input.env,\n        shell: input.shell,\n      });\n\n      return {\n        terminal,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\n/**\n * NEW: Phase 4 - Parallel Agent Spawning (10-20x faster)\n * Spawn multiple agents in parallel using ParallelSwarmExecutor\n */\nfunction createSpawnParallelAgentsTool(logger: ILogger): MCPTool {\n  return {\n    name: 'agents/spawn_parallel',\n    description: 'Spawn multiple agents in parallel (10-20x faster than sequential spawning)',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        agents: {\n          type: 'array',\n          items: {\n            type: 'object',\n            properties: {\n              type: { type: 'string', description: 'Agent type' },\n              name: { type: 'string', description: 'Agent name' },\n              capabilities: { type: 'array', items: { type: 'string' } },\n              priority: {\n                type: 'string',\n                enum: ['low', 'medium', 'high', 'critical'],\n                default: 'medium'\n              },\n            },\n            required: ['type', 'name'],\n          },\n          description: 'Array of agent configurations to spawn in parallel',\n        },\n        maxConcurrency: {\n          type: 'number',\n          default: 5,\n          description: 'Maximum number of agents to spawn concurrently',\n        },\n        batchSize: {\n          type: 'number',\n          default: 3,\n          description: 'Number of agents per batch',\n        },\n      },\n      required: ['agents'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Spawning parallel agents', {\n        count: input.agents?.length,\n        sessionId: context?.sessionId\n      });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const executor = context.orchestrator.getParallelExecutor();\n      if (!executor) {\n        throw new Error('ParallelSwarmExecutor not initialized');\n      }\n\n      // Convert input agents to ParallelAgentConfig format\n      const agentConfigs = input.agents.map((agent: any) => {\n        // Resolve legacy agent types to modern equivalents\n        const resolvedType = resolveLegacyAgentType(agent.type);\n\n        return {\n          agentId: `agent_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n          agentType: resolvedType,\n          originalType: agent.type,\n          task: `Spawn ${agent.name} agent`,\n          capabilities: agent.capabilities || [],\n          priority: agent.priority || 'medium',\n        };\n      });\n\n      const startTime = Date.now();\n      const sessions = await executor.spawnParallelAgents(agentConfigs, {\n        maxConcurrency: input.maxConcurrency || 5,\n        batchSize: input.batchSize || 3,\n      });\n\n      const elapsedTime = Date.now() - startTime;\n\n      return {\n        success: true,\n        agentsSpawned: sessions.size,\n        sessions: Array.from(sessions.entries()).map(([id, session]) => ({\n          agentId: id,\n          sessionId: session.sessionId,\n          status: session.status,\n        })),\n        performance: {\n          totalTime: elapsedTime,\n          averageTimePerAgent: elapsedTime / sessions.size,\n          speedupVsSequential: `~${Math.round((sessions.size * 750) / elapsedTime)}x`,\n        },\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\n/**\n * NEW: Phase 4 - Real-Time Query Control\n * Control running queries: pause, resume, terminate, change model\n */\nfunction createQueryControlTool(logger: ILogger): MCPTool {\n  return {\n    name: 'query/control',\n    description: 'Control running queries (pause, resume, terminate, change model)',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        action: {\n          type: 'string',\n          enum: ['pause', 'resume', 'terminate', 'change_model', 'change_permissions', 'execute_command'],\n          description: 'Control action to perform',\n        },\n        queryId: {\n          type: 'string',\n          description: 'ID of the query to control',\n        },\n        model: {\n          type: 'string',\n          enum: ['claude-3-5-sonnet-20241022', 'claude-3-5-haiku-20241022', 'claude-3-opus-20240229'],\n          description: 'Model to switch to (for change_model action)',\n        },\n        permissionMode: {\n          type: 'string',\n          enum: ['default', 'acceptEdits', 'bypassPermissions', 'plan'],\n          description: 'Permission mode to switch to (for change_permissions action)',\n        },\n        command: {\n          type: 'string',\n          description: 'Command to execute (for execute_command action)',\n        },\n      },\n      required: ['action', 'queryId'],\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Query control action', {\n        action: input.action,\n        queryId: input.queryId,\n        sessionId: context?.sessionId\n      });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const controller = context.orchestrator.getQueryController();\n      if (!controller) {\n        throw new Error('RealTimeQueryController not initialized');\n      }\n\n      let result;\n      switch (input.action) {\n        case 'pause':\n          result = await controller.pauseQuery(input.queryId);\n          break;\n        case 'resume':\n          result = await controller.resumeQuery(input.queryId);\n          break;\n        case 'terminate':\n          result = await controller.terminateQuery(input.queryId);\n          break;\n        case 'change_model':\n          if (!input.model) {\n            throw new Error('model parameter required for change_model action');\n          }\n          result = await controller.changeModel(input.queryId, input.model);\n          break;\n        case 'change_permissions':\n          if (!input.permissionMode) {\n            throw new Error('permissionMode parameter required for change_permissions action');\n          }\n          result = await controller.changePermissionMode(input.queryId, input.permissionMode);\n          break;\n        case 'execute_command':\n          if (!input.command) {\n            throw new Error('command parameter required for execute_command action');\n          }\n          result = await controller.executeCommand(input.queryId, input.command);\n          break;\n        default:\n          throw new Error(`Unknown action: ${input.action}`);\n      }\n\n      return {\n        success: true,\n        action: input.action,\n        queryId: input.queryId,\n        result,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\n/**\n * NEW: Phase 4 - List Active Queries\n * Get status of all active queries being controlled\n */\nfunction createListQueriesTool(logger: ILogger): MCPTool {\n  return {\n    name: 'query/list',\n    description: 'List all active queries and their status',\n    inputSchema: {\n      type: 'object',\n      properties: {\n        includeHistory: {\n          type: 'boolean',\n          default: false,\n          description: 'Include completed queries in the list',\n        },\n      },\n    },\n    handler: async (input: any, context?: ClaudeFlowToolContext) => {\n      logger.info('Listing queries', { sessionId: context?.sessionId });\n\n      if (!context?.orchestrator) {\n        throw new Error('Orchestrator not available');\n      }\n\n      const controller = context.orchestrator.getQueryController();\n      if (!controller) {\n        throw new Error('RealTimeQueryController not initialized');\n      }\n\n      const queries = controller.getAllQueries();\n\n      return {\n        success: true,\n        queries: Array.from(queries.entries()).map(([id, status]) => ({\n          queryId: id,\n          ...status,\n        })),\n        count: queries.size,\n        timestamp: new Date().toISOString(),\n      };\n    },\n  };\n}\n\nfunction getDefaultSystemPrompt(type: string): string {\n  const prompts = {\n    coordinator:\n      'You are a coordinator agent responsible for planning, delegating, and orchestrating tasks across multiple agents.',\n    researcher:\n      'You are a research agent specialized in gathering, analyzing, and synthesizing information from various sources.',\n    implementer:\n      'You are an implementation agent focused on writing code, creating solutions, and executing technical tasks.',\n    analyst:\n      'You are an analysis agent that identifies patterns, generates insights, and provides data-driven recommendations.',\n    custom: 'You are a specialized agent with custom capabilities defined by your configuration.',\n  };\n\n  return prompts[type as keyof typeof prompts] || prompts.custom;\n}\n"],"names":["getAvailableAgentTypes","resolveLegacyAgentType","enhanceToolWithAgentTypes","tool","availableTypes","enhancedTool","JSON","parse","stringify","addEnumToAgentTypeFields","obj","key","value","Object","entries","field","type","description","includes","enum","inputSchema","createClaudeFlowTools","logger","tools","createSpawnAgentTool","createSpawnParallelAgentsTool","createListAgentsTool","createTerminateAgentTool","createGetAgentInfoTool","createQueryControlTool","createListQueriesTool","createCreateTaskTool","createListTasksTool","createGetTaskStatusTool","createCancelTaskTool","createAssignTaskTool","createQueryMemoryTool","createStoreMemoryTool","createDeleteMemoryTool","createExportMemoryTool","createImportMemoryTool","createGetSystemStatusTool","createGetMetricsTool","createHealthCheckTool","createGetConfigTool","createUpdateConfigTool","createValidateConfigTool","createExecuteWorkflowTool","createCreateWorkflowTool","createListWorkflowsTool","createExecuteCommandTool","createListTerminalsTool","createCreateTerminalTool","enhancedTools","Promise","all","map","name","properties","capabilities","items","systemPrompt","maxConcurrentTasks","default","priority","environment","workingDirectory","required","handler","input","context","info","sessionId","orchestrator","Error","resolvedType","profile","id","Date","now","Math","random","toString","substr","getDefaultSystemPrompt","spawnAgent","agentId","originalType","status","timestamp","toISOString","includeTerminated","filterByType","agents","listAgents","filteredAgents","filter","agent","count","length","reason","graceful","terminateAgent","agentInfo","getAgentInfo","dependencies","assignToAgent","assignToAgentType","timeout","task","createdAt","taskId","createTask","assignTask","assignTaskToType","limit","offset","tasks","listTasks","getTask","cancelTask","tags","search","startTime","format","endTime","query","undefined","queryMemory","content","parentId","entry","version","entryId","storeMemory","deleteMemory","exportResult","exportMemory","filePath","mergeStrategy","importResult","importMemory","getSystemStatus","timeRange","metrics","getMetrics","deep","healthCheck","performHealthCheck","section","config","getConfig","restart","result","updateConfig","validation","validateConfig","workflow","parameters","executeWorkflow","assignTo","savePath","created","createWorkflow","directory","workflows","listWorkflows","command","args","cwd","env","terminalId","executeCommand","includeIdle","terminals","listTerminals","shell","terminal","createTerminal","maxConcurrency","batchSize","executor","getParallelExecutor","agentConfigs","agentType","sessions","spawnParallelAgents","elapsedTime","success","agentsSpawned","size","Array","from","session","performance","totalTime","averageTimePerAgent","speedupVsSequential","round","action","queryId","model","permissionMode","controller","getQueryController","pauseQuery","resumeQuery","terminateQuery","changeModel","changePermissionMode","includeHistory","queries","getAllQueries","prompts","coordinator","researcher","implementer","analyst","custom"],"mappings":"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"}